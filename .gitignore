# tiktok_checker.py
import asyncio
import aiohttp
import aiofiles
import random
import time
from typing import List, Optional

# --- إعدادات ---
CONCURRENCY = 20                # عدد الطلبات المتزامنة
MIN_DELAY = 0.3                 # أقل تأخير بين كل محاولة (ثواني)
MAX_DELAY = 1.2                 # أكبر تأخير (ثواني)
TIMEOUT = 10                    # مهلة الشبكة بالثواني
USER_AGENTS = [
    # مجموعة بسيطة من User-Agents؛ زيد أو استبدل إذا أردت
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 13_0) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Safari/605.1.15",
    "Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
]

# ضع هنا بروكسي بشكل dict إن أردت (مثال http)
# PROXY = "http://user:pass@host:port"  # أو None إذا بدون بروكسي
PROXY: Optional[str] = None

INPUT_FILE = "usernames.txt"
OUTPUT_FILE = "available.txt"

# --- منطق الفحص ---
async def check_username(session: aiohttp.ClientSession, username: str) -> Optional[bool]:
    """
    يرجع True إذا المتاح (غالبًا 404)، False إذا موجود، None إذا خطأ/محجوز/مشكلة.
    """
    url = f"https://www.tiktok.com/@{username}"
    headers = {
        "User-Agent": random.choice(USER_AGENTS),
        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
    }
    try:
        async with session.get(url, headers=headers, timeout=TIMEOUT, proxy=PROXY) as resp:
            status = resp.status
            # 200 -> موجود، 404 -> غالباً متاح، 301/302 -> قد يعيد توجيه (يتطلب فحص إضافي)
            if status == 404:
                return True
            elif status == 200:
                return False
            else:
                # حالات أخرى: 429 rate-limited, 301/302 redirect، 403 محجوب
                return None
    except asyncio.TimeoutError:
        return None
    except Exception:
        return None

async def worker(name: int, queue: asyncio.Queue, session: aiohttp.ClientSession, out_lock: asyncio.Lock):
    while not queue.empty():
        username = await queue.get()
        # تأخير عشوائي بسيط لتجنب الحظر
        await asyncio.sleep(random.uniform(MIN_DELAY, MAX_DELAY))
        result = await check_username(session, username)
        if result is True:
            async with out_lock:
                async with aiofiles.open(OUTPUT_FILE, "a", encoding="utf-8") as f:
                    await f.write(username + "\n")
                print(f"[AVAILABLE] {username}")
        elif result is False:
            print(f"[TAKEN] {username}")
        else:
            print(f"[UNKNOWN] {username} (retry later or check manually)")
        queue.task_done()

async def main():
    # قراءة اليوزرات من الملف
    try:
        async with aiofiles.open(INPUT_FILE, "r", encoding="utf-8") as f:
            lines = await f.readlines()
        usernames = [line.strip() for line in lines if line.strip()]
    except FileNotFoundError:
        print(f"لم أجد {INPUT_FILE}. أنشئ ملفاً وضع فيه اليوزرات بالتسلسل - كل سطر يوزر.")
        return

    queue = asyncio.Queue()
    for u in usernames:
        await queue.put(u)

    connector = aiohttp.TCPConnector(limit_per_host=CONCURRENCY, ssl=False)
    timeout = aiohttp.ClientTimeout(total=TIMEOUT + 5)
    out_lock = asyncio.Lock()

    async with aiohttp.ClientSession(connector=connector, timeout=timeout) as session:
        tasks = []
        for i in range(CONCURRENCY):
            tasks.append(asyncio.create_task(worker(i, queue, session, out_lock)))
        start = time.time()
        await queue.join()
        for t in tasks:
            t.cancel()
        elapsed = time.time() - start
        print(f"تم الفحص ({len(usernames)}) — المدة: {elapsed:.1f}s")
        print(f"النتائج المحفوظة في: {OUTPUT_FILE}")

if __name__ == "__main__":
    asyncio.run(main())
